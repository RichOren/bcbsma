/**
 * A helper function for recursively traversing the properties array of component definitions.
 * @param {object|array} definitionOrProperties Either the component definition of the properties
 * array inside the component definition
 * @param {function} fn The function to execute on each property
 */
export function traverseDefinitionProperties(definitionOrProperties: object | array, fn: Function): void;
/**
 * A helper function to return all property definitions, including nested ones.
 * @param {array} properties The array of property definitions
 * @param {function} [filterFn] A function to check if a given prop should be excluded
 */
export function getAllNestedPropertyDefinitions(definition: any, filterFn?: Function | undefined): any[];
export function changeTemplate(viewMetadata: any, templateDefinition: any, selectedTemplateDefinition: any, regionsToHide?: Set<any>): any;
/**
 * Sort an array of template definitions, accounting for order of numeric
 * words ("One", "Two", "Three") found in template name or label
 * @param {Array<object>} templates Array of template definitions to sort
 */
export function sortTemplateDefinitions(templates: Array<object>): object[];
/**
 * A fetch a component definition using either name or type. If searching by type, you can specify
 * a subtype to filter further.
 * @param {object} params
 * @param {string} [params.name] The component name
 * @param {string} [params.type] The component type
 * @param {string} [params.subtype] The component subtype
 * @param {object} options
 * @param {object} [options.skipLoadCustomerComponents] Whether to skip loading customer components
 */
export function fetchComponentDefinitions(params: {
    name?: string | undefined;
    type?: string | undefined;
    subtype?: string | undefined;
}, options?: {
    skipLoadCustomerComponents?: object | undefined;
}): Promise<any>;
/**
 * Helper function that handles retrieving Field component definitions. Currently, it only returns a
 * hashmap of name: description pairs, so the respective field names contain references to the
 * corresponding property types from Constellation.
 * @param {array<string>} availableFieldTypesDPResults list of result entries of D_pzAvailableFieldTypes
 */
export function fetchAndBuildFieldTypeMappings(availableFieldTypesDPResults: array<string>): Promise<{
    reference: string;
    DeferLoad: string;
}>;
/**
 * A helper function that evaluates each visibility expression in the property definitions and
 * returns Set containing names of fields which are to be hidden.
 * @param {Array<object>} properties Array of property definitions
 * @param {object} dependencies Dynamic/contextual information needed to evaluate the expression
 * @param {string} [dependencies.componentType] The type of the component
 * @param {string} [dependencies.viewType] The type of view: 'case', 'data', 'landingpage'
 * @param {object} dependencies.metadataConfig The metadata config with the current values
 * @returns {Set}
 */
export function getPropertiesToHide(properties: Array<object>, { componentType, viewType, ruleViewType, metadataConfig, isCaseTypeWorkObjectSource, isDataObjectSource, referencedViewTemplate, referencedViewTemplateSubtype, referencedViewType, viewAuthoringContext, isHybridApp, isQueryableSource, viewTemplate, autoGenerated, isGenAIEnabled, }: {
    componentType?: string | undefined;
    viewType?: string | undefined;
    metadataConfig: object;
}): Set<any>;
export function processAndEvaluateExpression(nameOfTheExpressionProp: any, expressionDependencies: any, propertyDefinitions: any): boolean;
/**
 * A helper function to filter an array of objects based on an expression string. Currently this
 * only supports use of '$this' in the left-hand-side parts of the expression, and also does not
 * support comparing with current metadata config values (i.e. use of $id in the expression).
 * @param {string} expression The filter expression to be evaluated
 * @param {Array<unknown>} items The array of items to be filtered
 * @returns {Array<unknown>} items
 */
export function filterItemsWithExpression(expression: string, items: Array<unknown>): Array<unknown>;
/**
 * Get the default metadata config from a definition. Interpolate any values
 * @param {Object} definition Component definition
 * @param {Object} metadata Metadata used for finding dynamic values
 */
export function getDefaultConfig(definition: Object, metadata?: Object): any;
/**
 * based on the template name and subtype, return true if its a dashboard
 * does NOT include the subType of DASHBOARD
 * @param {String} name name of the Template
 * @param {String} subtype subtype of the Template
 */
export function isDashboardTemplate(name: string, subtype: string): boolean;
//# sourceMappingURL=component-definition.d.ts.map